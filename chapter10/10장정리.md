# 10장 객체지향 쿼리 언어

---

## 10.1 객체지향 쿼리 소개
다음은 가장 단순한 검색방법이다.
+ 식별자로 조회 EntityManager.find()
+ 객체 그래프 탐색(예:a.getB().getC())

이 두가지 검색방법만으로 애플리케이션을 개발하기는 어렵다.

<br> 예를들어 회원테이블에서 나이가 30살 이상인 회원을 조회하고 싶을때 
모든 회원 엔티티를 메모리에 올려두고 에플리케이션에서 30살 이상인 회원을 검색하는 것은 현실성이 없다.
<br> 따라서 좀 더 현실적이고 복잡한 검색 방법이 필요한데 결국 데이터는 데이터베이스에 있으므로 SQL로 
필요한 내용을 최대한 걸러서 조회해야 한다.
<br> 그런데 ORM을 사용하면 테이블이 아닌 엔티티 개체로 개발하므로 테이블 대상이 아닌 엔티티 객체 대상으로 하는 방법이 필요하다.
<br> 이 문제를 해결하기 위해 만들어진 것이 `JPQL`이며, 다음과 같은 특징이 있다.

+ 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
+ SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.

SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면 JPQL은 엔티티 객체를 대상으로 하는 객체지향 쿼리이다.
<br> JPQL을 사용하면 JPA는 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. 그리고 조회한 결과로
엔티티 객체를 생성해서 반환한다. 

JPQL을 한마디로 정의하면 객체지향 SQL이라고할 수 있으며 SQL 문법이 비슷하여 몇가지 차이점만 이해하면 쉽게 적응이 가능하다.

JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공하며 JPA가 공식 지원하는 기능은 다음과 같다.
+ JPQL (Java Persistence Query Language)
+ Criteria 쿼리 (Criteria Query) : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
+ 네이티브 SQL (Native SQL) : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.

JPA가 공식으로 지원하지 않는 검색 방법
+ QueryDSL : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스모음, 비표준 오픈소스 프레임워크
+ JDBC 직접사용, MyBatis 같은 SQL 매퍼 프레임워크 사용 : 필요하면 JDBC를 직접 사용

### 10.1.1 JPQL 소개
엔티티 객체를 조회하는 객체지향 쿼리이다.
<br> 문법은 SQL과 비슷하고 ANSI 표준 SQL이 제공하는 기능을 유사하게 지원한다.
<br> JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. 
그리고 데이터베이스  방언(Dialect)만 변경하면 JPQL을 수정하지 않아도 된다.
<br> JPQL은 SQL보다 간결하다. 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL보다 코드가 간결하다.

``` java
@Entity(name="Member")      // name 속성의 기본값은 클래스 명
public class Member {

    @Column(name="name")
    private String username;
    //...
}
```
```
// 쿼리 생성
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```
위의 예제는 JPQL을 사용하여 회원이름이 kim인 엔티티를 조회하는 방법이다.
조건절에 보면 m.username 은 테이블 컬럼명이 아니라 엔티티 객체의 필드명이다. 
em.createQuery() 메소드에 실행할 JPQL 구문과 반환할 엔티티 클래스 타입을 넘겨주고 getResultList()
메소드를 실행하면 JPA는 JPQL을 SQL로 변환해서 데이터베이스를 조회하고 결과값을 엔티티로 생성해서 반환한다.

### 10.1.2 Criteria 쿼리 소개
Criteria는 JPQL을 생성하는 빌더 클래스이다.
<br>Criteria의 장점은 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.
만약 JPQL에서 `select m from Membeeee m`처럼 오타가 있을때 컴파일도 성공하고 애플리케이션 배포도 가능하다.
<br> 문제는 해당 쿼리가 실행되는 런타임 시점에 오류가 발생한다는 점이 문자 쿼리문의 단점이다.
반면에 Criteria는 코드로 작성하여 컴파일 시점에 오류를 발견할 수 있다.
<br> 이것뿐만 아니라 문자로 작성한 JPQL보다 Criteria를 사용하면 다음과 같은 장점이 있다.
+ IDE를 사용하면 코드 자동완성 지원
+ 동적 쿼리를 작성하기 편함

``` 
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 실행
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
위의 예제를 보면 `m.get("username")`을 보면 필드 명을 문자로 작성했다. 만약에 이부분도 문자가 아닌 코드로 작성하고
싶으면 메타 모델을 사용하면 된다.
자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있다.
<br> JPA는 이 기능을 사용해서 Member 엔티티 클래스로부터 Member_라는 Criteria 전용 클래스를 생성하는데 
이것을 메타 모델이라 하며, 메타 모델의 자세한 설명은 뒤에서 하겠다.

```
// 메타 모델 사용전 -> 사용 후
m.get("username") => m.get(Member_.username)
```
위의 메타 모델을 사용함으로써 코드로 작성이 가능했으며 동적 쿼리를 작성할 때 유용하다.
이처럼 Criteria가 가진 장점은 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다. 
따라서 사용하기 불편하고 Criteria로 작성한 코드 가독성이 떨어진다는 단점이 있다.

### 10.1.3 QueryDSL 소개
QueryDSL도 Criteria처럼 JPQL 빌더 역할을 한다.
<br> QueryDSL 장점은 코드 기반이면서 단순하고 사용하기 쉽다. 작성한 코드도 JPQL과 비슷해서 가독성이 좋다.
``` java
// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> members = query.from(member)
                    .where(member.username.eq("kim"))
                    .list(member);
```
위의 QMember는 Member 엔티티 클래스를 기반으로 생성한 QueryDSL 쿼리 전용 클래스이다.

### 10.1.4 네이티브 SQL 소개
JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 네이티브 SQL이라 한다.
JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있다. 
<br> 오라클 데이터베이스만 사용하는 CONNECT BY 기능이나 특정 데이터베이스에서만 동작하는 SQL 힌트 같은 것이며,
이러한 기능들은 전혀 표준화되어 있지 않으므로 JPQL에서 사용할 수 없다.
<br> 그리고 SQL은 지원하지만 JPQL이 지원하지 않는 기능도 있다. 이때 네이티브 SQL을 사용하면 해결이 가능하다.
```
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```
네이티브 SQL 단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 하며, 데이터베이스가 변경되면 쿼리문을 수정해야한다.

### 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용
JDBC 커넥션에 직접 접근하고 싶으면 JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않으므로, JPA 구현체가 제공하는 
방법을 사용해야 한다.
```
Session session = entityManager.unwrap(Session.class);
session.doWork(new Work() {
    @Override
    public void execute(Connection connection) throws SQLException {
        // work...
    }
});
```
먼저 JPA EntityManager에서 하이버네이트 Session을 구한다. 그리고 session의 doWork() 메소드를 호출하면 된다.
<br> JDBC나 Mybatis를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 한다.
<br> 왜냐하면 JDBC를 사용하든 Mybatis를 사용하든 모두 JPA를 우회해서 데이터베이스를 접근하기 때문에 JPA가 전혀 인식하지 못하는
문제를 가지고 있다. 최악의 경우에는 영속성 컨텍스트와 데이터베이스를 불일치 상태로 만들어 데이터 무결성을 훼손할 수 있다.
<br> 이런 문제를 해결하는 방법은 JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스
와 영속성 컨텍스트를 동기화하면 된다.

## 10.2 JPQL 사용방법
JPQL 특징 정리
+ JPQL은 객체지향 쿼리 언어이다. 테이블을 대상으로 쿼리하는 것이 아닌 엔티티 객체를 대상으로 쿼리한다.
+ JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
+ JPQL은 결국 SQL로 변환한다.

### 10.2.1 기본 문법과 쿼리 API
JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.
<br> 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 INSERT 문은 없다.
```
select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]
    
update_문 :: = update_절 [where_절]
delete_문 :: = delete_절 [where_절]
```

### SELECT 문
+ SELECT 문은 다음과 같다.
```
SELECT m FROM Member AS m where m.username = 'Hello'
```
+ 대소문자 구분 
  <br> 엔티티와 속성은 대소문자를 구분한다. (Member, username) 반면에 SELECT, FROM, AS 같은 JPQL 키워드는 
  대소문자를 구분하지 않는다.
+ 엔티티 이름
  <br> JPQL에서 사용한 Member는 클래스명이 아니라 엔티티이다. 엔티티명은 `@Entity(name="이름")`로 지정할 수 있다.
  <br> 엔티티명을 지정하지 않으면 클래스명을 기본값으로 사용한다.
+ 별칭은 필수
  <br> Member AS m을 보면 Member에 m이라는 별칭을 주었다.
  <br> JPQL은 별칭을 필수로 사용해야 한다. 별칭없이 사용하면 잘못된 문법이라는 오류가 발생한다.
  ```
  SELECT username FROM Member m // 잘못된 문법, username을 m.username 으로 고쳐야한다.
  ```

### TypeQuery, Query
작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다. 쿼리 객체는 TypeQuery와 Query가 있는데
반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체를 사용하고 반환 타입을 명확하게 지정할 수 없으면
Query 객체를 사용하면 된다. 
```
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for(Member member : resultList) {
    System.out.println("member = " + member);
}
```
em.createQuery()의 두번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환한다.

```
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

for(Object o : resultList) {
    Object[] result = (Object[]) o;     // 결과가 둘 이상이면 Object[] 반환
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```
### 결과 조회
다음 메소들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.
+ query.getResultList() : 결과를 컬력션으로 반환한다. 만약 결과가 없으면 빈 컬렉션을 반환한다.
+ query.getSingleResult() : 결과가 정확히 하나일 때 사용한다.
  - 결과가 없으면 javax.persistence.NoResultException 예외가 발생한다.
  - 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 예외가 발생한다.

### 10.2.2 파라미터 바인딩
JPQL은 위치 기준, 이름 기준 파라미터 바인딩을 지원한다. 참고로 JDBC는 위치 기준 파라미터 바인딩만 지원한다.
+ 이름 기준 파라미터
  파라미터 이름으로 구분하는 방법이며 이름 앞에 `:`를 사용한다.
  ```
  String usernameParam = "User1";
  
  TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
  
  query.setParameter("username", usernameParam);
  List<Member> resultList = query.getResultList();
  ```
+ 위치 기준 파라미터
  `?` 다음에 위치 값을 주면 된다. 위치 값은 1부터 시작한다.
  ```
  List<Member> members = em.createQuery("SELECT m FROM m WHERE m.username
    =?1", Member.class)
        .setParameter(1, usernameParam)
        .getResultList();
  ```

위치 기준 파라미터 방식보다는 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다.

### 10.2.3 프로젝션
SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라 하고 `[SELECT {프로젝션 대상} FROM]`으로 대상을 선택한다.
<br> 대상은 엔티티, 엠비디드 타입, 스칼라 타입이 있다. 스칼라 타입은 숫자, 문자 등 기본 데이터 타입을 뜻한다.

+ 엔티티 프로젝션
  ``` 
  SELECT m FROM Member m // 회원
  SELECT m.team FROM Member m // 팀
  ```
  원하는 엔티티 객체를 프로젝션 대상으로 사용한 것이며 컬럼을 하나하나 나열해서 조회해야 하는 SQL과 차이가 있다.
  이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리한다.

+ 임베디드 타입 프로젝션
  엔티티 프로젝션과 거의 비슷하게 사용된다. 임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.
  ```
  String query = "SELECT a FROM Address a";
  ```
  임베디드 타입인 Address를 조회의 시작점으로 사용해서 잘못된 쿼리이다.
  ```
  String query = "SELECT o.address FROM Order o;
  List<Address> address = em.createQuery(query, Address.class)
                                .getResultList();
  ```
  Order 엔티티가 시작점이다. 엔티티를 통해서 임베디드 타입을 조회할 수 있다.

임베디드 타입은 엔티티 타입이 아닌 값 타입이다. 따라서 이렇게 직접 조회한 임베디드 타입은
영속성 컨텍스트에서 관리되지 않는다.

+ 스칼라 타입 프로젝션
  숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라 한다.
  ```
  List<String> username = em.createQuery("SELECT username FROM Member m", String.class)
                            .getResultList();
  ```
  
+ 여러 값 조회
  엔티티를 대상으로 조회하면 편리하겠지만, 꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다.
  프로젝션에 여러 값을 선택하면 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.
  ```
  Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
  List resultList = query.getResultList();
  
  Iterator iterator = resultList.iterator();
  while (iterator.hasNext()) {
    Object[] row = (Object[]) iterator.next();
    String username = (String) row[0];
    Integer age = (Integer) row[1];
  }
  ```
  제네릭에 Object[]를 사용하면 조금 더 간결하게 개발할 수 있다.
  ```
  List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
                                    .getResultList();
  for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age = (Integer) row[1];
  }
  ```
  스칼라 타입뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.
  ```
  List<Object[]> resultList = em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
                                    .getResultList();
  for (Object[] row : resultList) {
    Member member = (Member) row[0];     // 엔티티
    Product product = (Product) row[1];  // 엔티티
    int orderAmount = (Integer) row[2];  // 스칼라
  }
  ```
  이때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

+ NEW 명령어
  직전에 username, age 두 필드를 프로젝션해서 지정할 수 없으므로 TypeQuery를 사용할 수 없다.
  따라서 Object[]를 반환받았다. 실제 어플리케이션 개발시에는 Object[]를 직접 사용하지 않고 다음과 같이 DTO
  객체를 생성하여 사용한다.
  ```
  List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
                                .getResultList();
  // 객체 변환 작업
  List<UserDTO> userDTOs = new ArrayList<UserDTO>();
  for(Object[] row : resultList) {
    UserDTO userDTO = new UserDTO((String)row[0], (Integer)row[1]);
    userDTOs.add(userDTO);
  }
  return userDTOs;
  ```
  ```java
  public class UserDTO {
    private String username;
    private int age;
  
    public UserDTO(String username, int age) {
        this.username = username;
        this.age = age;
    }
    // ...
  }
  ```
  위의 작업을 NEW 명령어를 사용하여 바꾸면 다음과 같다. 
  ```
  TypedQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age)
                                FROM Member m", UserDTO.class);
  List<UserDTO> resultList = query.getResultList();
  ```
  SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정할 수 있는데 이 클래스의 생성자에
  JPQL 조회 결과를 넘겨줄 수 있다. 
  <br> 그리고 NEW 명령어를 사용한 클래스로 TypeQuery 사용할 수 있어서 단순 변환 작업을 줄일 수 있다.

  작업시 주의 사항 <br>
   1 패키지 명을 포함한 전체 클래스 명을 입력해야 한다.<br>
   2 순서와 타입이 일치하는 생성자가 필요하다.

### 10.2.4 페이징 API
데이터베이스마다 페이징 처리하는 SQL 문법이 다 다르다. <br>
따라서 JPA는 페이징을 다음 두 API로 추상화 했다.
+ setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
+ setMaxResults(int maxResult) : 조회할 테이터 수
```
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC",
                            Member.class);
query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```
11번째부터 시작해서 총 20건의 데이터를 조회하는 예제이다.
따라서 11~30번 데이터를 조회한다.
<br> 데이터베이스마다 다른 페이징 처리를 같은 API로 처리할 수 있는 것은 데이터베이스 방언(Dialect) 덕분이다.
<br> JPQL이 방언에 따라 해당 데이터베이스 SQL 문으로 변환하기 때문이다. 
<br> 만일, 페이징 SQL을 더 최적화하고 싶다면 네이티브 SQL을 직접 사용해야 한다.

### 10.2.5 집합과 정렬

#### 집합 함수 

| 함수             | 설명                                                                                                     |
|----------------|--------------------------------------------------------------------------------------------------------|
| COUNT          | 결과 수를 구한다. 반환 타입 : Long                                                                                |
| MAX, MIN       | 최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용                                                                        |
| AVG            | 평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입 : Double                                                               |
| SUM            | 합을 구한다. 숫자타입만 사용할 수 있다. 반환 타입 : 정수합 Long, 소수합 Double, BigInteger합: BigInteger, BigDecimal합: BigDecimal |

#### 집합 함수 사용 시 참고사항
+ NULL 값은 무시하므로 통계에 잡히지 않는다(DISTINCT가 정의되어 있어도 무시)
+ 만약 값이 없는데 SUM, AVG, MAX, MIN 함수를 사용하면 NULL 값이 된다. 단 COUNT는 0이 된다.
+ DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.
  예) SELECT COUNT(DISTINCT m.age) FROM Member m
+ DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다.

#### GROUP BY, HAVING
